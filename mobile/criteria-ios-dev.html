<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Recommandations accessibilité Orange</title>
        
      
       <!-- Copyright © 2014 Monotype Imaging Inc. All rights reserved -->
      <link rel="stylesheet" href="../boosted/css/orangeHelvetica.css">
      <!-- Copyright © 2016 Orange SA. All rights reserved -->
      <link rel="stylesheet" href="../boosted/css/orangeIcons.css">
      <link rel="stylesheet" href="../boosted/css/boosted.css">

      <!-- Style pour la mise en forme des exemples de code -->
      <link rel="stylesheet" href="/css/dark.min.css">

      <!-- Styles perso -->
      <link rel="stylesheet" href="../css/reco.css">
      <link rel="stylesheet" href="./css/reco-custom.css">

      <script src="./js/jquery.min.js"></script>
      <script src="./js/jquery.validate.min.js"></script>
      <script src="./js/lunr.min.js"></script>
      <script src="./js/lunr.stemmer.support.js"></script>
      <script src="./js/lunr.fr.min.js"></script>      
      
      <!-- Favicons -->
      <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
      <link rel="icon" href="/images/favicon.ico">            
</head>
<body>
    <div class="skip-links sr-only">
        <a id="skip-nav" href="#sidebar">Aller à la navigation</a>
        <a id="skip-content" href="#content">Aller au contenu</a>
    </div>
    <header role="banner">
      <nav class="navbar navbar-dark navbar-fixed-top">
          <button class="navbar-toggler hidden-sm-up" type="button" data-toggle="collapse" data-target="#collapsingNavbar">
              <span class="sr-only">Menu de navigation</span>
              <span class="icon-menu"></span>
          </button>
          
              <a href="index.html" class="navbar-brand"><img src="../boosted/img/ORANGE_LOGO_rgb.jpg" alt="Retour à l’accueil" title="Retour à l’accueil"/></a>
              <ul class="nav navbar-nav collapse navbar-toggleable-xs pull-xs-left" id="collapsingNavbar">
                  <li class="nav-item"><a class="nav-link" href="../index.html">Accueil</a></li>                                    
                  <li class="nav-item">
                    <a class="nav-link" href="../web/index.html">Site Web</a>
                  </li>
                  <li class="nav-item active mobile">
                    <a href="../mobile/index.html" class="nav-link">Application mobile</a>
                    <ul id="navigation" class="nav navbar-nav">
                        <li><a class="page-index" href="index.html">Présentation</a></li>
                        <li><a class="page-criteria-android" href="criteria-android.html" aria-haspopup="true" aria-expanded="false">Critères incontournables Android</a></li>
                        <li><a class="page-criteria-ios" href="criteria-ios.html" aria-haspopup="true" aria-expanded="false">Critères incontournables iOS</a></li>            
                        <li><a class="page-mdan" href="mdan.html">Démonstrateur d’accessibilité sur mobile mDAN</a></li>                                                                  
                        <li><a class="page-screen-reader" href="screen-reader.html">Lecteur d’écran</a></li>
                        <li><a class="page-links" href="links.html">Liens utiles</a></li>
                        <li><a class="page-contact" href="contact.html">Contact</a></li>
                        <li><a class="page-about" href="about.html">À propos</a></li>                        
                    </ul>                                        
                  </li>   
                  <li class="nav-item"><a href="../others/index.html" class="nav-link">Contenu éditorial</a></li>
                  <li class="nav-item language hidden-sm-up">
                    <a href="#" class="nav-link active" aria-disabled="true" aria-label="version française">fr</a><a lang="en" aria-label="english version" href="../mobile_EN/index.html" class="nav-link">en</a>
                  </li>
              </ul> 
              <ul class="nav navbar-nav pull-xs-right" id="secondNavBar">        
                <li class="nav-item hidden-xs-down">
                  <span id="cdu">
                    <a href="http://confort-plus.orange.com/" target="_blank" 
                      title="Découvrir Confort + : extension navigateur permettant d’adapter le confort de lecture lors de la consultation d’un site web." 
                      aria-label="Découvrir Confort + : extension navigateur permettant d’adapter le confort de lecture lors de la consultation d’un site web (nouvelle fenêtre)">
                      Découvrir Confort
                      <span>+</span>
                    </a>
                  </span>
                </li>
                <li class="nav-item language hidden-xs-down">
                  <a href="#" class="nav-link active" aria-disabled="true" aria-label="version française">fr</a><a lang="en" aria-label="english version" href="../mobile_EN/index.html" class="nav-link">en</a> 
                </li>
                <li class="nav-item">
                    <a href="#searchbar" class="nav-link icon" id="searchIcon" data-toggle="collapse" aria-expanded="false" aria-controls="searchbar">
                        <span class="sr-only">Afficher la barre de recherche</span>
                        <span class="icon-search" aria-hidden="true"></span>
                    </a>                    
                </li>                
            </ul>             
          
          <form action="./search.html" class="navbar-form navbar-right collapse" role="search" id="searchbar">
            <label for="search">Rechercher</label>
            <input placeholder="Saisissez votre recherche" type="text" id="search" name="q">
            <button type="submit" class="btn btn-secondary icon">
              <span class="sr-only">Rechercher</span>
              <span class="icon-search" aria-hidden="true"></span>
            </button>
          </form>
      </nav>      
    </header>
    
    <nav>
      <span class="sr-only">Vous êtes ici&nbsp;: </span>
      <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="/mobile/index.html">Application mobile</a></li>
      </ol>
    </nav>
    
    <main role="main" class="container-fluid">
      <div class="row row-offcanvas row-offcanvas-left">       
        <div role="navigation" id="sidebar" class="col-xs-6 col-sm-3 sidebar-offcanvas">
        </div>
        <div class="col-xs-12 col-sm-9" id="content">          
          <h1 id="les-crit-res-incontournables-sous-ios-pour-le-d-veloppement">Les critères incontournables sous iOS pour le développement</h1>
<script>$(document).ready(function () {

    setBreadcrumb([{"label":"Les critères incontournables sous iOS", "url": "./criteria-ios.html"},
        {"label":"Pour le développement"}
    ]);
    addSubMenu([
        {"label":"Pour la conception","url":"criteria-ios-conception.html"}, 
        {"label":"Pour le développement","url":"criteria-ios-dev.html", "expanded": true},
        {"label":"WWDC","url":"criteria-ios-wwdc.html"}
    ]);    
});</script>

<p><span data-menuitem="criteria-ios"></span></p>
<p>Ce guide a pour objectif de présenter les différentes options du <abbr>SDK</abbr> d’accessibilité sous iOS 11 en associant&nbsp;:</p>
<ul>
<li>Des explications détaillées concernant les attributs et méthodes d&#39;accessibilité.</li>
<li>Des exemples de code en Swift 4 et en Objective C.</li>
</ul>
<p></br>... et des liens vers la <a href="https://developer.apple.com/documentation/uikit/accessibility"><code>documentation officielle d&#39;Apple</code></a>.</p>
<h2 id="alternatives-textuelles">Alternatives textuelles</h2>
<h3 id="description">Description</h3>
<p>Sous iOS, la vocalisation d’un élément s’effectue à travers 4 attributs&nbsp;: <code>label</code>, <code>hint</code>, <code>value</code> et <code>trait</code>.<br>L’ordre de vocalisation est toujours le même (<code>label</code>, <code>value</code>, <code>trait</code> et <code>hint</code>), il ne peut pas être changé et la vocalisation est réalisée en une seule fois à l’arrivée sur l’élément.  </p>
<p>Une section de ce guide étant dédiée au <code>trait</code>, nous décrivons ici les 3 autres attributs&nbsp;:  </p>
<ul>
<li><strong>accessibilityLabel</strong>&nbsp;: le label permet de préciser le titre spécifique à l’accessibilité qui est lu par <span lang="en">VoiceOver</span> en lieu et place du texte du composant si celui-ci en possède un, ce qui permet d’avoir un texte de composant plus explicite que celui affiché à l’écran.
</br>Par exemple, dans le cas d’un bouton dont le titre est « OK », on peut indiquer que le bouton sert à valider un choix.</li>
<li><strong>accessibilityValue</strong>&nbsp;: la valeur d’un élément est, par défaut, le pourcentage de progression.
</br>À noter que, pour la plupart des éléments ajustables disponibles dans le <abbr>SDK</abbr>, cette <code>value</code> n’a pas besoin d’être précisée car le système restitue automatiquement la valeur à l’utilisateur via <span lang="en">VoiceOver</span>.</li>
<li><strong>accessibilityHint</strong>&nbsp;: le <code>hint</code> permet de décrire le comportement du composant en incorporant des explications supplémentaires.
</br>Exemple&nbsp;: «&nbsp;cliquez pour obtenir le résultat&nbsp;».  </li>
</ul>
<p>Ces attributs sont disponibles via l’<i lang="en">interface builder</i> de Xcode mais également accessibles en programmation.
</br>Tout élément dérivant de <code>UIView</code> possède ces attributs qui acceptent une chaîne de caractère les rendant subséquemment internationalisables.</p>
<h3 id="exemple">Exemple</h3>
<pre><code class="objective-c">
@interface ChangeTextView() {

    __weak IBOutlet UILabel * monLabel;
    __weak IBOutlet UIProgressView * maProgressView;
}
@end

@implementation ChangeTextView

- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];

    monLabel.accessibilityLabel = @"bonjour";
    monLabel.accessibilityHint = @"Ceci est un commentaire supplémentaire.";

    maProgressView.accessibilityValue = @"45 pour cent";
}
@end
</code></pre><pre><code class="swift">
<p>class ChangeTextView: UIViewController {</p>
<pre><code>@IBOutlet weak var monLabel: UILabel!
@IBOutlet weak var maProgressView: UIProgressView!

override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    monLabel.accessibilityLabel = &quot;bonjour&quot;
    monLabel.accessibilityHint = &quot;Ceci est un commentaire supplémentaire.&quot;

    maProgressView.accessibilityValue = &quot;45 pour cent&quot;

}</code></pre><p>}
</code></pre></p>
<h3 id="liens">Liens</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615181-accessibilitylabel"><code>accessibilityLabel</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615117-accessibilityvalue"><code>accessibilityValue</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615093-accessibilityhint"><code>accessibilityHint</code></a></li>
</ul>
<h2 id="nature-des-l-ments">Nature des éléments</h2>
<h3 id="description">Description</h3>
<p>L’attribut <code>accessibilityTraits</code> permet de donner une information à l’<abbr>API</abbr> d’accessibilité sur la nature d’un composant.
</br>On peut décider ainsi qu’un item de liste soit pris en compte comme un bouton par <span lang="en">VoiceOver</span> car celui-ci est cliquable.
</br>De ce fait, l’<code>accessibilityTrait</code> joue également sur la vocalisation de l’élément car cette nature est restituée par <span lang="en">VoiceOver</span>.  </p>
<p>Cet attribut d’accessibilité est disponible via l’<i lang="en">interface builder</i> de Xcode mais également utilisable directement via le code.  </p>
<p>Il existe beaucoup de traits dont les principaux sont fournis ci-dessous&nbsp;:  </p>
<ul>
<li><strong>accessibilityTraitNone</strong>&nbsp;: supprime toute valeur sémantique à l’élément.</li>
<li><strong>accessibilityTraitButton</strong>&nbsp;: ajoute le trait «&nbsp;bouton&nbsp;», l’élément est vu comme un bouton par <span lang="en">VoiceOver</span>.</li>
<li><strong>accessibilityTraitLink</strong>&nbsp;: utile pour définir un label en tant que «&nbsp;lien&nbsp;».</li>
<li><strong>accessibilityTraitHeader</strong>&nbsp;: permet de définir un élément comme un en-tête (voir la section <a href="criteria-ios-conception.html#titre-et-en-t-te">«&nbsp;titre et en-tête&nbsp;»</a>).</li>
<li><strong>accessibilityTraitAdjustable</strong>&nbsp;: permet de définir un élément comme un élément «&nbsp;ajustable&nbsp;», c’est-à-dire un élément dont la valeur instantanée peut être modifiée via un <a href="https://help.apple.com/iphone/9/#/iph3e2e2281">geste spécifique</a> de <span lang="en">VoiceOver</span>.</li>
</ul>
<h3 id="exemple">Exemple</h3>
<pre><code class="objective-c">
- (void)customTraits() {
    //Spécification d'un UIPageControl avec le trait ’ajustable’.
    pageControl.accessibilityTraits = UIAccessibilityTraitAdjustable;

    //Ajout d'un en-tête.  
    defaultHeaderViewCell.accessibilityTraits = UIAccessibilityTraitHeader;

    //Combinaison possible de plusieurs traits.  
    onePageButton.accessibilityTraits = UIAccessibilityTraitButton + UIAccessibilityTraitSelected;
}
</code></pre><pre><code class="swift">
<p>func customTraits() {
    //Spécification d&#39;un UIPageControl avec le trait ’ajustable’.
    pageControl.accessibilityTraits = UIAccessibilityTraitAdjustable</p>
<pre><code>//Ajout d&#39;un en-tête. 
defaultHeaderViewCell.accessibilityTraits = UIAccessibilityTraitHeader

//Combinaison possible de plusieurs traits. 
onePageButton.accessibilityTraits = UIAccessibilityTraitButton + UIAccessibilityTraitSelected</code></pre><p>}
</code></pre></p>
<h3 id="lien">Lien</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615202-accessibilitytraits"><code>accessibilityTraits</code></a></li>
</ul>
<h2 id="masquer-des-l-ments-l-accessibilit-">Masquer des éléments à l’accessibilité</h2>
<h3 id="description">Description</h3>
<p>Il est possible de masquer des éléments aux outils d’accessibilité grâce aux attributs d’accessibilité mais aussi de forcer certains éléments à être visibles pour les outils d’accessibilité uniquement.  </p>
<ul>
<li><strong>isAccessibilityElement</strong>&nbsp;: booléen qui permet d’indiquer qu’un élément est visible ou non de l’<abbr>API</abbr> d’accessibilité (de <span lang="en">VoiceOver</span> ou autre).</li>
<li><strong>accessibilityElementsHidden</strong>&nbsp;: booléen qui permet d’indiquer que les éléments fils de l’élément cible sont visibles ou non de l’<abbr>API</abbr> d’accessibilité.</li>
<li><strong>accessibilityViewIsModal</strong>&nbsp;: booléen qui permet de rendre visible ou non les éléments frères de l’élément cible à l’<abbr>API</abbr> d’accessibilité.
</br>Très utile pour rendre accessible des <i lang="en">popup custom view</i> par exemple.  </li>
</ul>
<p>L’attribut <code>accessibilityElement</code> est disponible via l’<i lang="en">interface builder</i> de Xcode mais est également utilisable directement via le code.
</br>Les deux autres attributs sont utilisables uniquement via le code.</p>
<h3 id="exemple">Exemple</h3>
<p>L&#39;idée est de créer un carré rouge qui va contenir 2 autres carrés (bleu et jaune) pour appliquer les attributs définis précedémment.
<img style="max-width: 500px; height: auto; " src="./images/iOSdev/MasquerDesElements_1.png" /></p>
<pre><code class="objective-c">
- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];

    //Création d'un élément père dans lequel 2 autres éléments fils vont être insérés.
    CGRect parentViewRect = CGRectMake(100.0, 100.0, 40.0, 40.0);
    UIView * myParentView = [[UIView alloc]initWithFrame:parentViewRect];
    myParentView.backgroundColor = [UIColor redColor];

    [UIApplication.sharedApplication.keyWindow addSubview:myParentView];

    //L'élément père ne doit pas être accessible pour servir de conteneur à ses enfants.
    //Si la valeur est à 'YES', seul cet élément sera accessible sans ses enfants.
    myParentView.isAccessibilityElement = NO;

    //Indication du conteneur que ses enfants peuvent ne pas être accessibles même s'ils sont définis comme tels.
    //Si cette valeur est à 'NO' et la précedénte à 'NO', seuls ces élements seront accessibles.
    myParentView.accessibilityElementsHidden = NO;

    [self createViewWithColor:[UIColor yellowColor] 
                       inside:myParentView];
    [self createViewWithColor:[UIColor blueColor] 
                       inside:myParentView];
}

- (void)createViewWithColor:(UIColor*)color
                     inside:(UIView*)parentView {

    float delta = (color == [UIColor yellowColor]) ? 0.0 : 20.0;

    CGRect rect = CGRectMake(10.0 + delta, 10.0 + delta, 10.0, 10.0);
    UIView * theView = [[UIView alloc]initWithFrame:rect];
    theView.backgroundColor = color;

    [parentView addSubview:theView];

    theView.isAccessibilityElement = YES;
}
</code></pre><pre><code class="swift">
<p>override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)</p>
<pre><code>    //Création d&#39;un élément père dans lequel 2 autres éléments fils vont être insérés.
    let parentViewRect = CGRect.init(x: 100.0,
                                     y: 100.0,
                                     width: 40.0,
                                     height: 40.0)
    let myParentView = UIView.init(frame: parentViewRect)
    myParentView.backgroundColor = .red

    UIApplication.shared.keyWindow?.addSubview(myParentView)

    //L&#39;élément père ne doit pas être accessible pour servir de conteneur à ses enfants.
    //Si la valeur est à &#39;true&#39;, seul cet élément sera accessible sans ses enfants.
    myParentView.isAccessibilityElement = false

    //Indication du conteneur que ses enfants peuvent ne pas être accessibles même s&#39;ils sont définis comme tels.
    //Si cette valeur est à &#39;false&#39; et la précedénte à &#39;false&#39;, seuls ces élements seront accessibles.
    myParentView.accessibilityElementsHidden = false

    self.createViewWithColor(.yellow, inside: myParentView)
    self.createViewWithColor(.blue, inside: myParentView)
}

func createViewWithColor(_ color:UIColor, inside parentView:UIView) {

    let delta:CGFloat = ((color == .yellow) ? 0.0 : 20.0)
    let rect = CGRect.init(x: 10.0 + delta,
                           y: 10.0 + delta,
                           width: 10.0,
                           height: 10.0)

    let theView = UIView.init(frame: rect)
    theView.backgroundColor = color

    parentView.addSubview(theView)

    theView.isAccessibilityElement = true
}</code></pre><p></code></pre></p>
<h3 id="liens">Liens</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615141-isaccessibilityelement"><code>isAccessibilityElement</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615080-accessibilityelementshidden"><code>accessibilityElementsHidden</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615089-accessibilityviewismodal"><code>accessibilityViewIsModal</code></a></li>
</ul>
<h2 id="d-clencher-une-vocalisation">Déclencher une vocalisation</h2>
<h3 id="description">Description</h3>
<p>Il est très facile de déclencher des vocalisations avec <span lang="en">VoiceOver</span>.
</br>Attention, nous parlons de vocalisation avec <span lang="en">VoiceOver</span> (ce qui implique que <span lang="en">VoiceOver</span> soit activé) et pas de <abbr>TTS</abbr> (<span lang="en">Text To Speech</span>) qui fonctionne indépendamment de l’activation ou non de <span lang="en">VoiceOver</span>.
</br></br>Pour déclencher une vocalisation qui se fera dans la langue du système, il faut envoyer une notification à l’<abbr>API</abbr> d’accessibilité via la méthode <strong>UIAccessibilityPostNotification</strong> avec en paramètres la notification permettant de déclencher une vocalisation <strong>UIAccessibilityAnnouncementNotification</strong> et la chaîne de caractères à vocaliser.</p>
<h3 id="exemple">Exemple</h3>
<pre><code class="objective-c">
UIAccessibilityPostNotification(UIAccessibilityAnnouncementNotification, @"Message pour la vocalisation.");
</code></pre><pre><code class="swift">
<p>UIAccessibilityPostNotification(UIAccessibilityAnnouncementNotification, &quot;Message pour la vocalisation.&quot;)
</code></pre></p>
<h3 id="liens">Liens</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/1615194-uiaccessibilitypostnotification"><code>UIAccessibilityPostNotification</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilityannouncementnotification"><code>UIAccessibilityAnnouncementNotification</code></a></li>
</ul>
<h2 id="conna-tre-l-tat-des-options-d-accessibilit-">Connaître l’état des options d’accessibilité</h2>
<h3 id="description">Description</h3>
<p>Est-ce que <span lang="en">VoiceOver</span> est activé&nbsp;? Est-ce que le mode audio-mono est activé&nbsp;?
</br>Plusieurs fonctions du <span lang="en">framework</span> <code>UIKit</code> permettent de connaître les statuts de ces options d&#39;accessibilité.
 </br>La plus utile est certainement celle qui permet de savoir si <span lang="en">VoiceOver</span> est activé au moment de l’appel (<strong>UIAccessibilityIsVoiceOverRunning</strong>).
 </br></br>D&#39;autres fonctions, peut-être moins utiles à première vue, sont fournies dans les liens ci-après.</p>
<h3 id="exemple">Exemple</h3>
<pre><code class="objective-c">
    BOOL isVoiveOverRunning = (UIAccessibilityIsVoiceOverRunning() ? 1 : 0);
    BOOL isSwitchControlRunning = (UIAccessibilityIsSwitchControlRunning() ? 1 : 0);

    NSLog(@"VoiceOver vaut %d et SwitchControl vaut %d.", isVoiveOverRunning, isSwitchControlRunning);
</code></pre><pre><code class="swift">
<pre><code>let isVoiceOverRunning = (UIAccessibilityIsVoiceOverRunning() ? 1 : 0)
let isSwitchControlRunning = (UIAccessibilityIsSwitchControlRunning() ? 1 : 0)

print(&quot;VoiceOver vaut \(isVoiceOverRunning) et SwichControl vaut \(isSwitchControlRunning).&quot;)</code></pre><p></code></pre></p>
<h3 id="liens">Liens</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/1615087-uiaccessibilitydarkersystemcolor"><code>UIAccessibilityDarkerSystemColorsEnabled</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1648479-uiaccessibilityisassistivetouchr"><code>UIAccessibilityIsAssistiveTouchRunning</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615156-uiaccessibilityisboldtextenabled"><code>UIAccessibilityIsBoldTextEnabled</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615112-uiaccessibilityisclosedcaptionin"><code>UIAccessibilityIsClosedCaptioningEnabled</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615189-uiaccessibilityisgrayscaleenable"><code>UIAccessibilityIsGrayscaleEnabled</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615173-uiaccessibilityisguidedaccessena"><code>UIAccessibilityIsGuidedAccessEnabled</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615167-uiaccessibilityisinvertcolorsena"><code>UIAccessibilityIsInvertColorsEnabled</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615123-uiaccessibilityismonoaudioenable"><code>UIAccessibilityIsMonoAudioEnabled</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615133-uiaccessibilityisreducemotionena"><code>UIAccessibilityIsReduceMotionEnabled</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615074-uiaccessibilityisreducetranspare"><code>UIAccessibilityIsReduceTransparencyEnabled</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615103-uiaccessibilityisshaketoundoenab"><code>UIAccessibilityIsShakeToUndoEnabled</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615109-uiaccessibilityisspeakscreenenab"><code>UIAccessibilityIsSpeakScreenEnabled</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615154-uiaccessibilityisspeakselectione"><code>UIAccessibilityIsSpeakSelectionEnabled</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615131-uiaccessibilityisswitchcontrolru"><code>UIAccessibilityIsSwitchControlRunning</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/1615187-uiaccessibilityisvoiceoverrunnin"><code>UIAccessibilityIsVoiceOverRunning</code></a></li>
</ul>
<h2 id="informer-d-une-modification-sur-la-page">Informer d’une modification sur la page</h2>
<h3 id="description">Description</h3>
<p>Lors d’un changement de contenu sur une page, il est possible de notifier l’<abbr>API</abbr> d’accessibilité de ce changement à travers différentes notifications.
</br>Pour ce faire, il faut envoyer une notification de modification à l’<abbr>API</abbr> d’accessibilité via la méthode <strong>UIAccessibilityPostNotification</strong>.<br></br>Il existe plusieurs notifications de modification, mais les deux plus utiles sont&nbsp;:</p>
<ul>
<li><strong>UIAccessibilityLayoutChangedNotification</strong>&nbsp;: permet de spécifier à l’<abbr>API</abbr> d’accessibilité qu’une partie de la page a été modifiée et doit être accompagné d&#39;un <code>NSString</code> ou d&#39;un <code>UIObject</code>.
</br>Avec un <code>NSString</code>, la notification se comporte comme une <strong>UIAccessibilityAnnouncementNotification</strong> et lance une vocalisation <span lang="en">VoiceOver</span>.
</br>Avec un <code>UIObject</code>, le focus est repositionné sur l’élément précisé.
</br>Cette notification est très similaire à <strong>UIAccessibilityAnnouncementNotification</strong> mais son utilisation doit être mise en avant dès lors qu&#39;une modification dynamique du contenu se produit.</li>
<li><strong>UIAccessibilityScreenChangedNotification</strong>&nbsp;: permet d’annoncer un changement global de la page et accepte soit <code>nil</code>, soit l’élément qui doit recevoir le focus.
</br>Avec <code>nil</code>, la notification vocalise et sélectionne le premier élément accessible de la page.
</br>Avec un <code>UIObject</code>, le focus est repositionné sur l’élément précisé en lançant une vocalisation <span lang="en">VoiceOver</span>.
</br>Le son utilisé pour notifier la modification est similaire à l&#39;arrivée d&#39;une nouvelle page.</li>
</ul>
<h3 id="exemple">Exemple</h3>
<pre><code class="objective-c">
//L'élément 'myLabel' est sélectionné et vocalisé avec sa nouvelle valeur.
- (IBAction)tapHere:(UIButton *)sender {

    myLabel.accessibilityLabel = @"Ceci est un nouveau label.";
    UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel);
}

//Le premier élément accessible de la page est sélectioné et vocalisé avec un son spécifique.
- (IBAction)clic:(UIButton *)sender {

    UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, nil);
}
</code></pre><pre><code class="swift">
<p>//L&#39;élément &#39;myLabel&#39; est sélectionné et vocalisé avec sa nouvelle valeur.
@IBAction func clicHere(_ sender: UIButton) {</p>
<pre><code>myLabel.accessibilityLabel = &quot;Ceci est un nouveau label.&quot;
UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel)</code></pre><p>}</p>
<p>//Le premier élément accessible de la page est sélectioné et vocalisé avec un son spécifique.
@IBAction func clic(_ sender: UIButton) {</p>
<pre><code>UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, mySecondLabel)</code></pre><p>}
</code></pre></p>
<h3 id="liens">Liens</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/1615194-uiaccessibilitypostnotification"><code>UIAccessibilityPostNotification</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitylayoutchangednotification"><code>UIAccessibilityLayoutChangedNotification</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilityscreenchangednotification"><code>UIAccessibilityScreenChangedNotification</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitypagescrollednotification"><code>UIAccessibilityPageScrolledNotification</code></a></li>
</ul>
<h2 id="modifier-la-langue-de-vocalisation">Modifier la langue de vocalisation</h2>
<h3 id="description">Description</h3>
<p>Afin de modifier la langue de prononciation de <span lang="en">VoiceOver</span> pour un mot ou un texte, il existe l’attribut <strong>accessibilityLanguage</strong>&nbsp;. </br>Disponible via le protocole <code>UIAccessibility</code>, cet attribut permet de redéfinir la langue de prononciation d’un texte.
</br>Par exemple, si on utilise cet attribut sur un <code>UILabel</code>, alors celui-ci sera vocalisé par <span lang="en">VoiceOver</span> dans la nouvelle langue donnée en valeur de l’attribut.</br></p>
<h3 id="exemple">Exemple</h3>
<pre><code class="objective-c">
- (IBAction)tapHere:(UIButton *)sender {

    myLabel.accessibilityLanguage = @"en";
    myLabel.accessibilityLabel = @"This is a new label. Thank you.";
    UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel);
}
</code></pre><pre><code class="swift">
<p>@IBAction func tapHere(_ sender: UIButton) {</p>
<pre><code>myLabel.accessibilityLanguage = &quot;en&quot;
myLabel.accessibilityLabel = &quot;This is a new label. Thank you.&quot;
UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel)</code></pre><p>}
</code></pre></p>
<h3 id="lien">Lien</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615192-accessibilitylanguage"><code>accessibilityLanguage</code></a></li>
</ul>
<h2 id="modifier-la-zone-de-focus-de-span-lang-en-voiceover-span-">Modifier la zone de focus de <span lang="en">VoiceOver</span></h2>
<h3 id="description">Description</h3>
<p>Dans le cas d’objet modifié dynamiquement ou d’élément ne dérivant pas de <code>UIView</code>, il est possible de déterminer la zone géographique d’accessibilité de cet élément, c’est-à-dire la zone que <span lang="en">VoiceOver</span> met en surbrillance lors du focus.  </p>
<ul>
<li><strong>accessibilityFrame</strong>&nbsp;: permet de définir cette zone via un rectangle (<code>CGRect</code>).
</br>Par défaut pour un élément dérivant de <code>UIView</code>, cette zone est la partie «&nbsp;visible&nbsp;» de la vue.</li>
<li><strong>accessibilityPath</strong>&nbsp;: équivalent à <code>AccessibilityFrame</code> mais permet de définir la zone via des courbes de Bézier.</li>
<li><strong>accessibilityActivationPoint</strong>&nbsp;: le «&nbsp;point&nbsp;» d’activation d’un élément pour les outils d’accessibilité.
</br>Par défaut, ce point est au centre de l’élément.</li>
</ul>
<h3 id="exemple">Exemple</h3>
<img style="max-width: 700px; height: auto; " src="./images/iOSdev/ModifierLaZoneDeFocus_1.png" />
<pre><code class="objective-c">
float xVal;
float yVal;
float widthVal;
float heightVal;

<ul>
<li><p>(void)viewDidAppear:(BOOL)animated {
  [super viewDidAppear:animated];</p>
<p>  xVal = myLabel.accessibilityFrame.origin.x;
  yVal = myLabel.accessibilityFrame.origin.y;
  widthVal = myLabel.accessibilityFrame.size.width;
  heightVal = myLabel.accessibilityFrame.size.height;</p>
</li>
</ul>
<p>}</p>
<p>//Première façon d&#39;augmenter la zone de focus.</p>
<ul>
<li><p>(IBAction)tapHere:(UIButton *)sender {</p>
<p>  myLabel.accessibilityFrame = CGRectMake(xVal,</p>
<pre><code>                                      yVal,
                                      widthVal + 100.0,
                                      heightVal+ 100.0);</code></pre><p>  UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel);
}</p>
</li>
</ul>
<p>//Seconde façon d&#39;augmenter la zone de focus (Bézier).</p>
<ul>
<li><p>(IBAction)clic:(UIButton *)sender {</p>
<p>  UIBezierPath * bezierPath = [UIBezierPath bezierPath];</p>
<p>  [bezierPath moveToPoint:CGPointMake(xVal, yVal)];</p>
<p>  [bezierPath addLineToPoint:CGPointMake(xVal + widthVal + 100.0, </p>
<pre><code>                                     yVal)];</code></pre><p>  [bezierPath addLineToPoint:CGPointMake(xVal + widthVal + 100.0, </p>
<pre><code>                                     yVal + heightVal+ 100.0)];</code></pre><p>  [bezierPath addLineToPoint:CGPointMake(xVal, </p>
<pre><code>                                     yVal + heightVal+ 100.0)];</code></pre><p>  [bezierPath closePath];</p>
<p>  myLabel.accessibilityPath = bezierPath;</p>
<p>  UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel);
}
</code></pre><pre><code class="swift">
  var xVal: CGFloat = 0.0
  var yVal: CGFloat = 0.0
  var widthVal: CGFloat = 0.0
  var heightVal: CGFloat = 0.0</p>
<p>  override func viewDidAppear(_ animated: Bool) {</p>
<pre><code>  super.viewDidAppear(animated)

  xVal = myLabel.accessibilityFrame.origin.x;
  yVal = myLabel.accessibilityFrame.origin.y;
  widthVal = myLabel.accessibilityFrame.size.width;
  heightVal = myLabel.accessibilityFrame.size.height;</code></pre><p>  }</p>
<p>  //Première façon d&#39;augmenter la zone de focus.
  @IBAction func clicHere(_ sender: UIButton) {</p>
<pre><code>  myLabel.accessibilityFrame = CGRect.init(x: xVal,
                                           y: yVal,
                                           width: widthVal + 100.0,
                                           height: heightVal + 100.0)

  UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, myLabel)</code></pre><p>  }</p>
<p>  //Seconde façon d&#39;augmenter la zone de focus (Bézier).
  @IBAction func clic(_ sender: UIButton) {</p>
<pre><code>  let bezierPath = UIBezierPath.init()

  bezierPath.move(to: CGPoint.init(x: xVal, y: yVal))

  bezierPath.addLine(to: CGPoint.init(x: xVal + widthVal + 100.0,
                                      y: yVal))
  bezierPath.addLine(to: CGPoint.init(x: xVal + widthVal + 100.0,
                                      y: yVal + heightVal + 100.0))
  bezierPath.addLine(to: CGPoint.init(x: xVal,
                                      y: yVal + heightVal + 100.0))
  bezierPath.close()

  myLabel.accessibilityPath = bezierPath

  UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, myLabel)</code></pre><p>  }
</code></pre></p>
</li>
</ul>
<h3 id="liens">Liens</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilityelement/1619579-accessibilityframe"><code>accessibilityFrame</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615159-accessibilitypath"><code>accessibilityPath</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615179-accessibilityactivationpoint"><code>accessibilityActivationPoint</code></a></li>
</ul>
<h2 id="grouper-des-l-ments">Grouper des éléments</h2>
<h3 id="description">Description</h3>
<p>On peut envisager de grouper des éléments pour vocaliser l&#39;ensemble formé en une seule fois et associer au groupe ainsi créé une action dédiée par exemple.
</br>Dans ce cas, on va créer une vue qui va englober les éléments impactés puis implémenter une action qui va indiquer l&#39;action à réaliser en cas d&#39;activation de la zone par l&#39;utilisateur.
</br>Dès lors, les éléments encapsulés ne doivent plus être considérés comme accessibles car seul leur conteneur doit être perçu comme tel.
</br></br>Une autre possibilité de groupement d&#39;éléments pourrait utiliser l’attribut <strong>shouldGroupAccessibilityChildren</strong>, booléen qui permet d’indiquer à <span lang="en">VoiceOver</span> qu’il doit grouper les enfants de la vue qui porte l’attribut.
</br>Cela permet notamment de faire des vocalisations uniques ou de définir un ordre de lecture <span lang="en">VoiceOver</span> particulier pour une partie de la page seulement (voir la section <a href="http://a11y-guidelines.orange.com/mobile/criteria-ios-dev.html#ordre-de-lecture">Ordre de lecture</a>).</p>
<h3 id="exemple">Exemple</h3>
<p>Nous avons un &#39;label&#39; et un &#39;switch control&#39; que nous allons souhaitons regrouper et traiter d&#39;un seul bloc.
</br><img style="max-width: 700px; height: auto; " src="./images/iOSdev/GrouperDesElements_1.png" /></p>
<pre><code class="objective-c">
- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];

    //Création de la vue qui va encapsuler le 'label' et le 'Switch Control'.
    CGRect wrapFrame = CGRectUnion(myLabel.frame, mySwitchControl.frame);
    wrapView = [[UIView alloc]initWithFrame: wrapFrame];

    wrapView.isAccessibilityElement = YES;
    wrapView.accessibilityLabel = myLabel.accessibilityLabel;
    wrapView.accessibilityValue = mySwitchControl.accessibilityValue;


    //Création de la manipulation qui va permettre une action sur la vue précédente.
    UITapGestureRecognizer * tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self
                                                                                  action:@selector(changeValue:)];
    tapGesture.numberOfTapsRequired = 1;
    [wrapView addGestureRecognizer:tapGesture];

    [self.view addSubview:wrapView];
}

- (void)changeValue:(UITapGestureRecognizer *)sender {
    mySwitchControl.on = ![mySwitchControl.accessibilityValue boolValue];
}
</code></pre><pre><code class="swift">
<pre><code>override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    //Création de la vue qui va encapsuler le &#39;label&#39; et le &#39;Switch Control&#39;.
    let wrapFrame = myLabel.frame.union(mySwitchControl.frame)
    let wrapView = UIView.init(frame: wrapFrame)

    wrapView.isAccessibilityElement = true
    wrapView.accessibilityLabel = myLabel.accessibilityLabel
    wrapView.accessibilityValue = mySwitchControl.accessibilityValue


    //Création de la manipulation qui va permettre une action sur la vue précédente.
    let tapGesture = UITapGestureRecognizer.init(target: self,
                                                 action: #selector(changeValue(sender:)))
    tapGesture.numberOfTapsRequired = 1;
    wrapView.addGestureRecognizer(tapGesture)

    self.view.addSubview(wrapView)
}

@objc func changeValue(sender: UITapGestureRecognizer) {

    let switchBoolValue = NSString(string:mySwitchControl.accessibilityValue!).boolValue
    mySwitchControl.setOn(!switchBoolValue,
                          animated: false)
}</code></pre><p></code></pre></p>
<h3 id="lien">Lien</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615143-shouldgroupaccessibilitychildren"><code>shouldGroupAccessibilityChildren</code></a></li>
</ul>
<h2 id="-v-nements-d-accessibilit-">Événements d’accessibilité</h2>
<h3 id="description">Description</h3>
<p>Le système iOS envoie un certain nombre d’événements d’accessibilité à destination des applications lors de la modification des options d’accessibilité.
</br>Par exemple, si <span lang="en">VoiceOver</span> est désactivé durant l’utilisation de l’application, celle-ci recevra l’événement <strong>UIAccessibilityVoiceOverStatusDidChange</strong>, ce qui peut être très utile couplé à la fonction <strong>UIAccessibilityIsVoiceOverRunning</strong> grâce à laquelle on peut exécuter un traitement particulier quand <span lang="en">VoiceOver</span> est activé.
</br>Mais que se passe-t-il si <span lang="en">VoiceOver</span> est désactivé alors que ce traitement a déjà eu lieu&nbsp;?
</br></br>C’est là que les événements système peuvent être utilisés et, en restant à leur écoute, il est possible d’appliquer des traitements spécifiques de manière dynamique.</p>
<h3 id="exemple">Exemple</h3>
<p>Dans cet exemple, on appelle une méthode spécifique au moment où le statut de VoiceOver ou du Switch Control change.</p>
<pre><code class="objective-c">
- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];

    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(methodToBeCalled:)
                                                 name:UIAccessibilitySwitchControlStatusDidChangeNotification
                                               object:nil];

    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(methodToBeCalled:)
                                                 name:UIAccessibilityVoiceOverStatusDidChangeNotification
                                               object:nil];
}

- (void)methodToBeCalled:(NSNotification *)notification {

    NSArray * checkStatus = @[@"NOK", @"OK"];

    NSLog(@"SWITCH CONTROL is %@ and VOICE OVER is %@",
          checkStatus[UIAccessibilityIsSwitchControlRunning()],
          checkStatus[UIAccessibilityIsVoiceOverRunning()]);
}
</code></pre><pre><code class="swift">
<pre><code>override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    NotificationCenter.default.addObserver(self,
                                           selector: #selector(methodToBeCalled(notification:)),
                                           name: .UIAccessibilitySwitchControlStatusDidChange,
                                           object: nil)

    NotificationCenter.default.addObserver(self,
                                           selector: #selector(methodToBeCalled(notification:)),
                                           name: .UIAccessibilityVoiceOverStatusDidChange,
                                           object: nil)
}

@objc private func methodToBeCalled(notification: Notification) {

    let switchControlStatus = (UIAccessibilityIsSwitchControlRunning() ? &quot;OK&quot; : &quot;NOK&quot;)
    let voiceOverStatus = (UIAccessibilityIsVoiceOverRunning() ? &quot;OK&quot; : &quot;NOK&quot;)

    print(&quot;SWITCH CONTROL is \(switchControlStatus) and VOICE OVER is \(voiceOverStatus).&quot;)
}</code></pre><p></code></pre></p>
<h3 id="lien">Lien</h3>
<p>Tous les événements sont disponibles sur la <a href="https://developer.apple.com/documentation/uikit/accessibility/notification_names?language=objc">documentation officielle d&#39;Apple</a>.</p>
<h2 id="taille-des-textes">Taille des textes</h2>
<h3 id="description">Description</h3>
<p>Depuis iOS7, il est possible de modifier dynamiquement la taille des textes d&#39;une application à l’aide du paramétrage du téléphone.
</br><img style="max-width: 600px; height: auto; " src="./images/iOSdev/TailleDesTextes_1.png" />
</br>Quelques points sont néanmoins essentiels pour la bonne utilisation de l&#39;<abbr>API</abbr> mise à disposition&nbsp;:</p>
<ul>
<li><p>Utiliser la police système pour les textes de l’application afin de se faciliter grandement la tâche même si l&#39;utilisation d&#39;autres polices est devenue nettement plus aisée depuis l&#39;arrivée de <code>UIFontMetrics</code> avec iOS11.</p>
<pre><code class="objective-c">
 __weak IBOutlet UILabel * fontHeadline;
 __weak IBOutlet UILabel * fontFootNote;

 //Utilisation de la font native pour le titre principal d'un page.
 UIFont * myFont = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline];

 //Définition de la font pour le titre principal d'une page.
 UIFont * fontHead = [UIFont fontWithName:@"Chalkduster" size:30.0];
 UIFontMetrics * fontHeadMetrics = [[UIFontMetrics alloc]initForTextStyle:UIFontTextStyleHeadline];
 fontHeadline.font = [fontHeadMetrics scaledFontForFont:fontHead];
</code></pre><pre><code class="swift">
<p> @IBOutlet weak var fontHeadline: UILabel!
 @IBOutlet weak var fontFootNote: UILabel!</p>
<p> //Utilisation de la police native par défaut pour le titre principal d&#39;une page.
 let myFont = UIFont.preferredFont(forTextStyle: .headline)</p>
<p> //Définition personnalisée de la police pour le titre principal d&#39;une page.
 let fontHead = UIFont(name: &quot;Chalkduster&quot;, size: 30.0)
 let fontHeadMetrics = UIFontMetrics(forTextStyle: .headline)
 fontHeadline.font = fontHeadMetrics.scaledFont(for: fontHead!)
</code></pre></p>
</li>
<li><p>Penser à écouter la notification <strong>UIContentSizeCategoryDidChange</strong> qui annonce le changement de la taille du texte à partir des paramètres du téléphone.
</br>Cette tâche est simplifiée depuis iOS10 où l&#39;attribut <strong>adjustsFontForContentSizeCategory</strong> se charge de la mise à jour automatique de la nouvelle taille de la police système au sein de l&#39;application (cet attribut ne peut s&#39;appliquer aux polices personnalisées qu&#39;avec l&#39;utilisation de <code>UIFontMetrics</code> en iOS11).
</br>Il est aussi possible d&#39;utiliser la méthode <strong>traitCollectionDidChange</strong> du protocole informel <code>UITraitEnvironment</code> qui sera automatiquement appelée dès qu&#39;une modification concernant l&#39;environnement de l&#39;interface iOS surviendra <em>(class/content size, portrait/paysage)</em>.</p>
<pre><code class="objective-c">
 //Écoute de la notification annonçant le changement de taille de la police.
 [[NSNotificationCenter defaultCenter] addObserver:self
                                          selector:@selector(methodToBeCalled:)
                                              name:UIContentSizeCategoryDidChangeNotification
                                            object:nil];

 //Modification automatique de la taille de la police sans utiliser la notification.
 fontHeadline.adjustsFontForContentSizeCategory = YES;

 - (void)methodToBeCalled:(NSNotification *)notification {

     //Il faut de nouveau affecter la police des éléments impactés lors du traitement de cette notification.
     fontFootNote.font = [UIFont preferredFontForTextStyle:UIFontTextStyleFootnote];
 }
</code></pre><pre><code class="swift">
<p> //Écoute de la notification annonçant le changement de taille de la police.
 NotificationCenter.default.addObserver(self,</p>
<pre><code>                                    selector:#selector(methodToBeCalled(notification:)),
                                    name: .UIContentSizeCategoryDidChange,
                                    object: nil)</code></pre><p> //Modification automatique de la taille de la police sans utiliser la notification.
 fontHeadline.adjustsFontForContentSizeCategory = true</p>
<p> @objc func methodToBeCalled(notification: Notification) {</p>
<pre><code> //Il faut de nouveau affecter la police des éléments impactés lors du traitement de cette notification.
 fontFootNote.font = UIFont.preferredFont(forTextStyle: .footnote)</code></pre><p> }
</code></pre></p>
</li>
<li><p>Ne pas oublier d&#39;adapter les contraintes graphiques aux éléments susceptibles de voir leur taille modifiée en privilégiant l&#39;utilisation de valeurs dynamiques.</p>
</li>
</ul>
<h3 id="liens">Liens</h3>
<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html#//apple_ref/doc/uid/TP40009542-CH4-SW65"><span lang="en">Dynamic Type <abbr>API</abbr></span></a></li>
<li><a href="https://developer.apple.com/documentation/foundation/nsnotification.name/1622948-uicontentsizecategorydidchange"><code>UIContentSizeCategoryDidChange</code></a></li>
<li><a href="https://developer.apple.com/documentation/uikit/uicontentsizecategoryadjusting/1771731-adjustsfontforcontentsizecategor?language=objc"><code>adjustsFontForContentSizeCategory</code></a></li>
</ul>
<h2 id="taille-des-l-ments-graphiques">Taille des éléments graphiques</h2>
<h3 id="description">Description</h3>
<p>Tout comme la taille des textes est adaptable selon les réglages d&#39;accessibilité (voir <a href="http://a11y-guidelines.orange.com/mobile/criteria-ios-dev.html#taille-des-textes">la rubrique précédente</a>), la taille des images ainsi que celle des éléments d&#39;une barre de tabulation ou d&#39;outils l&#39;est aussi mais <strong>uniquement depuis iOS11 avec Xcode 9</strong>.
</br></br>En suivant les différentes étapes ci-dessous, vous obtiendrez l&#39;effet défini précédemment et présenté graphiquement en exemple à la fin de cette rubrique&nbsp;:
</br></br>1. Sous Xcode, importer l&#39;image à grossir au format <code>pdf</code> à la résolution x1 dans le catalogue <code>xcassets</code>.
</br></br>2. Dans l&#39;<span lang="en">Image Set</span> qui vient d&#39;être créé, cocher la case <code>Preserve Vector Data</code> et spécifier <code>Single Scale</code> :
</br><img style="max-width: 700px; height: auto; " src="./images/iOSdev/TailleDesEltsGraphiques_4.png" />
</br></br>3. Si un <span lang="en">storyboard</span> est utilisé pour intégrer l&#39;image, cocher <code>Adjusts Image Size</code> dans la partie <span lang="en">Image View</span>, sinon mettre à <code>true</code> la propriété <code>adjustsImageSizeForAccessibilityContentSizeCategory</code> de l&#39;image si cette opération se fait de façon programmatique :
</br><img style="max-width: 350px; height: auto; " src="./images/iOSdev/TailleDesEltsGraphiques_5.png" />
</br></br>4. Si une <strong>barre de tabulation</strong> ou une <strong>barre d&#39;outils</strong> est aussi à intégrer dans l&#39;application, renouveler les 3 étapes précédentes pour chacune des images à utiliser en grossissement de l&#39;onglet au milieu de l&#39;écran puis associer l&#39;image souhaitée aux différents éléments impactés :
</br><img style="max-width: 350px; height: auto; " src="./images/iOSdev/TailleDesEltsGraphiques_6.png" />
</br><strong>ATTENTION : s&#39;assurer que les contraintes mises en place initialement permettent toujours un affichage cohérent et désiré après grossissement.</strong></p>
<h3 id="exemple">Exemple</h3>
<p>De façon à pouvoir tester à la fois le grossissement des images et celui d&#39;un onglet sélectionné, on crée une application contenant une barre de tabulations contenant 2 onglets dont seul le second nous intéresse et affiche l&#39;image du logo Orange.
</br></br>Après modification du grossissement de texte dans les réglages (voir <a href="http://a11y-guidelines.orange.com/mobile/criteria-ios-dev.html#taille-des-textes">la rubrique précédente</a>), on revient dans l&#39;application pour constater :</p>
<ul>
<li>Une taille de l&#39;image Orange nettement plus conséquente.</li>
<li>Au milieu de l&#39;écran, l&#39;affichage grossi de l&#39;onglet sur lequel on doit appuyer de façon continue pour provoquer cettte apparition.
</br><img style="max-width: 1200px; height: auto; " src="./images/iOSdev/TailleDesEltsGraphiques_9.png" /></li>
</ul>
<h3 id="lien">Lien</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitycontentsizecategoryimageadjusting/2890929-adjustsimagesizeforaccessibility"><code>adjustsImageSizeForAccessibilityContentSizeCategory</code></a></li>
</ul>
<h2 id="ordre-de-lecture">Ordre de lecture</h2>
<h3 id="description">Description</h3>
<p>Redéfinir l’ordre de lecture pour <span lang="en">VoiceOver</span> s’effectue en respectant le protocole <strong>UIAccessibilityContainer</strong>.
</br>L’idée est d’avoir un tableau des éléments de la vue qui définit l’ordre de lecture des éléments.
</br>Il est bien souvent nécessaire d’utiliser l’attribut <strong>shouldGroupAccessibilityElement</strong> afin d’avoir un ordre précis mais pour une partie seulement de la vue (le reste étant l’ordre naturel de lecture proposé par <span lang="en">VoiceOver</span>).</p>
<h3 id="exemple">Exemple</h3>
<p>Le meilleur exemple pour illustrer cette fonctionnalité est le clavier pour lequel les touches sucessives ne suivent pas forcément l&#39;ordre natif proposé par <span lang="en">VoiceOver</span>.
</br>Dans cet exemple, on veut l&#39;ordre suivant : 1, 2, 3, 4, 7, 6, 8, 9, 5.
</br>On crée  les 2 vues grise et bleue au sein desquelles on incorpore les chiffres appropriés comme défini ci-dessous :
</br><img style="max-width: 500px; height: auto; " src="./images/iOSdev/OrdreDeLecture_1.png" /></p>
<pre><code class="objective-c">
    __weak IBOutlet UIView * blueBlock;
    __weak IBOutlet UIView * greyColumn;

- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];

    //Lecture des 3 premiers nombres dans la vue grise.
    greyColumn.shouldGroupAccessibilityChildren = YES;

    // Lecture des chiffres 6, 8, 9 et 5 au sein du bloc bleu.
    blueBlock.isAccessibilityElement = NO;
    blueBlock.accessibilityElements = @[key_6,
                                        key_8,
                                        key_9,
                                        key_5];
}
</code></pre><pre><code class="swift">
<pre><code>@IBOutlet weak var greyColumn: UIView!
@IBOutlet weak var blueBlock: UIView!

override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    //Lecture des 3 premiers nombres dans la vue grise.
    greyColumn.shouldGroupAccessibilityChildren = true

    // Lecture des chiffres 6, 8, 9 et 5 au sein du bloc bleu.
    blueBlock.isAccessibilityElement = false
    blueBlock.accessibilityElements = [key_6,
                                       key_8,
                                       key_9,
                                       key_5]
}</code></pre><p></code></pre></p>
<h3 id="liens">Liens</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/accessibility/uiaccessibilitycontainer?language=objc"><code>UIAccessibilityContainer</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615143-shouldgroupaccessibilitychildren"><code>shouldGroupAccessibilityChildren</code></a></li>
</ul>
<h2 id="date-heure-et-nombres">Date, heure et nombres</h2>
<h3 id="description">Description</h3>
<p>La lecture des date, heure et nombres n&#39;est pas compliquée mais peut très vite devenir un réel casse-tête avec <span lang="en">VoiceOver</span>&nbsp;.</p>
<h4 id="lecture-des-dates-et-des-heures">Lecture des dates et des heures</h4>
<p>Si on met directement sous forme de texte la date ou l&#39;heure dans le <code>label</code>, on s&#39;aperçoit rapidement que le rendu n&#39;est pas naturel à l&#39;écoute.
</br><img style="max-width: 800px; height: auto; " src="./images/iOSdev/DateHeureNombres_10.png" />
</br>Il faut absolument formater les données en entrée pour obtenir une vocalisation descriptive naturelle et compréhensible.
</br><img style="max-width: 800px; height: auto; " src="./images/iOSdev/DateHeureNombres_4.png" /></p>
<pre><code class="objective-c">
    NSDateFormatter * dateFormatter = [[NSDateFormatter alloc]init];
    [dateFormatter setDateFormat:@"dd/MM/yyyy HH:mm"];

    NSDate * date = [dateFormatter dateFromString:@"01/04/2015 05:30"];

    dateLabel.text = [NSDateFormatter localizedStringFromDate:date
                                                    dateStyle:NSDateFormatterShortStyle
                                                    timeStyle:NSDateFormatterNoStyle];

    dateLabel.accessibilityLabel = [NSDateFormatter localizedStringFromDate:date
                                                                  dateStyle:NSDateFormatterMediumStyle
                                                                  timeStyle:NSDateFormatterNoStyle];


    hourLabel.text = [NSDateFormatter localizedStringFromDate:date
                                                    dateStyle:NSDateFormatterNoStyle
                                                    timeStyle:NSDateFormatterShortStyle];

    NSDateComponents * hourComponents = [[NSCalendar currentCalendar] components:NSCalendarUnitHour | NSCalendarUnitMinute
                                                                        fromDate:date];

    hourLabel.accessibilityLabel = [NSDateComponentsFormatter localizedStringFromDateComponents:hourComponents
                                                                                     unitsStyle:NSDateComponentsFormatterUnitsStyleSpellOut];
</code></pre><pre><code class="swift">
<pre><code>let dateFormatter = DateFormatter()
dateFormatter.dateFormat = &quot;dd/MM/yyyy HH:mm&quot;

let date = dateFormatter.date(from: &quot;01/04/2015 05:30&quot;)

dateLabel.text = DateFormatter.localizedString(from: date!,
                                               dateStyle: .short,
                                               timeStyle: .none)

dateLabel.accessibilityLabel = DateFormatter.localizedString(from: date!,
                                                             dateStyle: .medium,
                                                             timeStyle: .none)


hourLabel.text = DateFormatter.localizedString(from: date!,
                                               dateStyle: .none,
                                               timeStyle: .short)

let hourComponents = Calendar.current.dateComponents([.hour, .minute],
                                                     from: date!)
hourLabel.accessibilityLabel = DateComponentsFormatter.localizedString(from: hourComponents,
                                                                       unitsStyle: .spellOut)</code></pre><p></code></pre></p>
<h4 id="lecture-des-nombres">Lecture des nombres</h4>
<p>En indiquant la valeur d&#39;un nombre directement dans le texte d&#39;un <code>label</code>, la vocalisation se fera sur chacun des chiffres présentés rendant la véritable valeur du nombre difficile à deviner.
</br><img style="max-width: 500px; height: auto; " src="./images/iOSdev/DateHeureNombres_8.png" />
</br>Comme pour les date et heure, il faut formater la donnée en entrée pour qu&#39;elle puisse être analysée et vocalisée selon la véritable valeur du nombre qu&#39;elle représente.
</br><img style="max-width: 700px; height: auto; " src="./images/iOSdev/DateHeureNombres_5.png" /></p>
<pre><code class="objective-c">
    NSNumber * numberValue = @54038921.7;

    NSNumberFormatter * numberFormatter = [[NSNumberFormatter alloc]init];
    numberFormatter.numberStyle = NSNumberFormatterDecimalStyle;

    numberLabel.text = [numberFormatter stringFromNumber:numberValue];

    numberLabel.accessibilityLabel = [NSNumberFormatter localizedStringFromNumber:numberValue
                                                                      numberStyle:NSNumberFormatterSpellOutStyle];
</code></pre><pre><code class="swift">
<pre><code>let numberValue = NSNumber(value: 54038921.7)

numberLabel.text = NumberFormatter.localizedString(from: numberValue,
                                                   number: .decimal)

numberLabel.accessibilityLabel = NumberFormatter.localizedString(from: numberValue,
                                                                 number: .spellOut)</code></pre><p></code></pre></p>
<h4 id="lecture-des-num-ros-de-t-l-phone">Lecture des numéros de téléphone</h4>
<p>La problématique liée à la vocalisation d&#39;un numéro de téléphone est identique à celle des nombres puisqu&#39;elle s&#39;appuie entièrement sur le formatage à appliquer avec une prise en compte particulière des chiffres &quot;0&quot;.
</br>L&#39;exemple donné ci-dessous concerne la numérotation française avec une logique qui peut se décliner à n&#39;importe quel type de format de numérotation.
</br><img style="max-width: 550px; height: auto; " src="./images/iOSdev/DateHeureNombres_11.png" />
</br>L&#39;idée est de séparer chaque paire de chiffres par une virgule qui va fournir la ponctuation vocale.
</br><img style="max-width: 550px; height: auto; " src="./images/iOSdev/DateHeureNombres_6.png" /></p>
<pre><code class="objective-c">
    NSString * phoneNumberValue = @"06.11.22.33.06";
    NSArray * phoneNumberElts = [phoneNumberValue componentsSeparatedByString:@"."];

    NSNumberFormatter * nbFormatter = [[NSNumberFormatter alloc]init];
    nbFormatter.numberStyle = NSNumberFormatterSpellOutStyle;

    NSMutableString * spelledOutString = [[NSMutableString alloc]init];

    [phoneNumberElts enumerateObjectsUsingBlock:^(id  _Nonnull obj,
                                                  NSUInteger idx,
                                                  BOOL * _Nonnull stop) {
        NSString * elt = (NSString *)obj;

        if (idx != 0) {
            [spelledOutString appendString:@","];
        }

        if ([elt hasPrefix:@"0"]) {

            NSString * firstFigure = [nbFormatter stringFromNumber:@([[elt substringToIndex:1] integerValue])];
            NSString * secondFigure = [nbFormatter stringFromNumber:@([[elt substringFromIndex:1] integerValue])];

            [spelledOutString appendString:firstFigure];
            [spelledOutString appendString:secondFigure];

        } else {
            [spelledOutString appendString:[nbFormatter stringFromNumber:@([elt integerValue])]];
        }
    }];

    phoneNumberLabel.text = phoneNumberValue;
    phoneNumberLabel.accessibilityLabel = spelledOutString;
</code></pre><pre><code class="swift">
<pre><code>    let phoneNumberValue = &quot;06.11.22.33.06&quot;
    let phoneNumberElts = phoneNumberValue.components(separatedBy: &quot;.&quot;)

    let nbFormatter = NumberFormatter()
    nbFormatter.numberStyle = .spellOut

    var spelledOutString = String()

    for (index, elt) in phoneNumberElts.enumerated() {

        if (index != 0) {
            spelledOutString.append(&quot;,&quot;)
        }

        if (elt.hasPrefix(&quot;0&quot;)) {

            let firstFigureValue = Int(String(elt[elt.startIndex]))!
            let firstFigure = nbFormatter.string(from: NSNumber(value:firstFigureValue))
            spelledOutString.append(firstFigure!)

            let secondFigureValue = Int(String(elt[elt.index(elt.startIndex, offsetBy: 1)]))!
            let secondFigure = nbFormatter.string(from: NSNumber(value:secondFigureValue))
            spelledOutString.append(secondFigure!)

        } else {

            let figure = nbFormatter.string(from: NSNumber(value:Int(elt)!))
            spelledOutString.append(figure!)
        }
    }

    phoneNumberLabel.text = phoneNumberValue
    phoneNumberLabel.accessibilityLabel = spelledOutString</code></pre><p></code></pre></p>
<h3 id="liens">Liens</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/accessibility/uiaccessibilitycontainer?language=objc"><code>UIAccessibilityContainer</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615143-shouldgroupaccessibilitychildren"><code>shouldGroupAccessibilityChildren</code></a></li>
</ul>
<h2 id="contr-le-de-s-lection">Contrôle de sélection</h2>
<h3 id="description">Description</h3>
<p>L&#39;utilisation du contrôle de sélection s&#39;articule autour du mode point et du mode élément définis ci-dessous.
</br><img style="max-width: 700px; height: auto; " src="./images/iOSdev/ControlesDeSelection.png" />
</br>La sélection des éléments avec le mode élément fonctionne globalement bien quand les éléments proposés sont natifs et que l&#39;application n&#39;est pas trop compliquée graphiquement.
</br>Il peut très bien arriver que ce mode de sélection ne suive pas la logique souhaitée et ne propose pas les éléments dans l&#39;ordre désiré.</p>
<h4 id="personnalisation-du-mode-l-ment">Personnalisation du mode élément</h4>
<p>La structure utilisée pour l&#39;exemple est présentée ci-dessous grâce à l&#39;<span lang="en">InterfaceBuilder</span> de Xcode :
</br><img style="max-width: 700px; height: auto; " src="./images/iOSdev/ControleDeSelectionIB_1.png" />
</br>Afin de personnaliser la sélection de ces éléments, on souhaite :</p>
<ul>
<li>Créer 2 groupes {Test_1 + Test_2 ; Btn 5 + Btn 6} sélectionnables en mode élément.</li>
<li>Avoir uniquement les éléments restants Btn 1 et Btn 2 accessibles séparément.</li>
</ul>
<pre><code class="objective-c">
@interface ViewController2 ()

@property (weak, nonatomic) IBOutlet UIStackView * btnsParentView;
@property (weak, nonatomic) IBOutlet UIButton * btn1;
@property (weak, nonatomic) IBOutlet UIButton * btn2;
@property (weak, nonatomic) IBOutlet UIButton * btn5;
@property (weak, nonatomic) IBOutlet UIButton * btn6;

@end


@implementation ViewController2
- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];

    //Création du premier groupe 'testWrap' en COMBINANT les boutons 'Test_1' et 'Test_2'.
    UIButton * testOneButton = [self.view viewWithTag:1];
    UIButton * testTwoButton = [self.view viewWithTag:2];
    CGRect testWrapFrame = CGRectUnion(testOneButton.frame, testTwoButton.frame);

    UIAccessibilityElement * testWrap = [[UIAccessibilityElement alloc]initWithAccessibilityContainer:self.view];

    testWrap.isAccessibilityElement = false;
    testWrap.accessibilityFrame = testWrapFrame;
    testWrap.accessibilityNavigationStyle = UIAccessibilityNavigationStyleCombined; //Property specifique au contrôle de sélection.
    testWrap.accessibilityElements = @[testOneButton, testTwoButton];


    //Création du second groupe 'secondGroup' en SÉPARANT les boutons 1 et 2.
    CGRect secondGroupRect = CGRectUnion(_btn1.frame, _btn2.frame);
    CGRect secondGroupFrame = [_btnsParentView convertRect:secondGroupRect
                                                    toView:self.view];
    UIAccessibilityElement * secondGroup = [[UIAccessibilityElement alloc]initWithAccessibilityContainer:_btnsParentView];

    secondGroup.isAccessibilityElement = false;
    secondGroup.accessibilityFrame = secondGroupFrame;
    secondGroup.accessibilityNavigationStyle = UIAccessibilityNavigationStyleSeparate;
    secondGroup.accessibilityElements = @[_btn1, _btn2];


    //Création du troisième groupe 'thirdGroup' en COMBINANT les boutons 5 et 6.
    CGRect thirdGroupRect = CGRectUnion(_btn1.frame, _btn2.frame);
    CGRect thirdGroupFrame = [_btnsParentView convertRect:thirdGroupRect
                                                   toView:self.view];
    UIAccessibilityElement * thirdGroup = [[UIAccessibilityElement alloc]initWithAccessibilityContainer:_btnsParentView];

    thirdGroup.isAccessibilityElement = false;
    thirdGroup.accessibilityFrame = thirdGroupFrame;
    thirdGroup.accessibilityNavigationStyle = UIAccessibilityNavigationStyleCombined;
    thirdGroup.accessibilityElements = @[_btn5, _btn6];


    self.view.accessibilityElements = @[testWrap, 
                                        secondGroup, 
                                        thirdGroup];
}
@end
</code></pre><pre><code class="swift">
<p>class ViewController: UIViewController {</p>
<pre><code>@IBOutlet weak var btnsParentView: UIStackView!
@IBOutlet weak var btn1: UIButton!
@IBOutlet weak var btn2: UIButton!
@IBOutlet weak var btn5: UIButton!
@IBOutlet weak var btn6: UIButton!


override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)

    //Création du premier groupe &#39;testWrap&#39; en COMBINANT les boutons &#39;Test_1&#39; et &#39;Test_2&#39;.
    let testOneButton = self.view.viewWithTag(1) as? UIButton
    let testTwoButton = self.view.viewWithTag(2) as? UIButton
    let testWrapFrame = testOneButton?.frame.union((testTwoButton?.frame)!)

    let testWrap = UIAccessibilityElement(accessibilityContainer: self.view)

    testWrap.isAccessibilityElement = false
    testWrap.accessibilityFrame = testWrapFrame!
    testWrap.accessibilityNavigationStyle = .combined   //Property specifique au contrôle de sélection.
    testWrap.accessibilityElements = [testOneButton!, testTwoButton!]


    //Création du second groupe &#39;secondGroup&#39; en SÉPARANT les boutons 1 et 2.
    let secondGroupRect = btn1.frame.union(btn2.frame)
    let secondGroupFrame = btnsParentView.convert(secondGroupRect,
                                                  to: self.view)
    let secondGroup = UIAccessibilityElement(accessibilityContainer: btnsParentView)

    secondGroup.isAccessibilityElement = false
    secondGroup.accessibilityFrame = secondGroupFrame
    secondGroup.accessibilityNavigationStyle = .separate
    secondGroup.accessibilityElements = [btn1, btn2]


    //Création du troisième groupe &#39;thirdGroup&#39; en COMBINANT les boutons 5 et 6.
    let thirdGroupRect = btn5.frame.union(btn6.frame)
    let thirdGroupFrame = btnsParentView.convert(thirdGroupRect,
                                                 to: self.view)
    let thirdGroup = UIAccessibilityElement(accessibilityContainer: btnsParentView)

    thirdGroup.isAccessibilityElement = false
    thirdGroup.accessibilityFrame = thirdGroupFrame
    thirdGroup.accessibilityNavigationStyle = .combined
    thirdGroup.accessibilityElements = [btn5, btn6]


    self.view.accessibilityElements = [testWrap,
                                       secondGroup, 
                                       thirdGroup]
}</code></pre><p>}
</code></pre></p>
<p></br>Le rendu de ce code est visualisable ci-dessous :
</br><img style="max-width: 1100px; height: auto; " src="./images/iOSdev/ControleDeSelection_1.png" />
</br>Les groupes créés permettent d&#39;accéder directement aux éléments qu&#39;ils contiennent dès qu&#39;ils sont activés.</p>
<h3 id="lien">Lien</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1615200-accessibilitynavigationstyle"><code>accessibilityNavigationStyle</code></a></li>
</ul>
<h2 id="valeurs-contin-ment-ajustables">Valeurs continûment ajustables</h2>
<h3 id="description">Description</h3>
<p>Des éléments graphiques comme le <code>picker</code>, le <code>stepper</code> ou encore le <code>slider</code> permettent de changer de façon continue la valeur qu&#39;ils proposent de modifier.
</br><img style="max-width: 700px; height: auto; " src="./images/iOSdev/ValeursAjustables_1.png" />
</br>Quand on ne voit pas la modification dynamique se faire ou qu&#39;on n&#39;en est pas informé vocalement, il devient très compliqué de pouvoir se rendre compte de ce qui se passe.
</br>La méthodologie utilisée pour solutionner cette problématique pour une personne non voyante utilisant <span lang="en">VoiceOver</span> reste la même pour ces trois éléments, c&#39;est pourquoi seul le cas du <code>stepper</code> sera traité.
</br></br>L&#39;implémentation de cet objet graphique est relativement simple mais son utilisation avec VoiceOver requiert quelques ajustements pour obtenir un meilleur parcours utilisateur.
</br>Si on crée un <span lang="en">stepper</span> auquel on ajoute un <code>label</code> pour afficher sa valeur, on obtient le résultat suivant :
</br><img style="max-width: 900px; height: auto; " src="./images/iOSdev/ValeursAjustables_2.png" />
</br>À partir de là, on s&#39;aperçoit que le focus doit être déplacé pour :</p>
<ul>
<li>Atteindre chacun des deux éléments permettant d&#39;augmenter ou de diminuer la valeur.</li>
<li>Connaître la valeur obtenue via le <code>label</code>.</li>
</ul>
<p>De plus, il n&#39;y a aucune indication de changement de la valeur en temps réel.
</br>Certes, rien n&#39;est bloquant mais, si l&#39;on souhaite réellement mettre en place cet objet avec un rendu le plus fluide possible, ces quelques remarques conduisent tout naturellement à concevoir différemment cet exemple pourtant si simple.
</br></br>L&#39;idée est de pouvoir changer la valeur du <span lang="en">stepper</span>, être informé de son changement et d&#39;en connaître la valeur par le biais d&#39;un unique objet.
</br>Il faut donc <strong>regrouper le <span lang="en">stepper</span> et le <code>label</code></strong> <em>(à l&#39;aide d&#39;une <span lang="en">StackView</span> par exemple)</em> puis associer <strong><code>UIAccessibilityTraitAdjustable</code></strong> à ce nouveau groupe accessible.
</br>Ce nouveau <code>trait</code> va permettre de modifier de façon continue la valeur de l&#39;objet auquel il est associé en implémentant <strong>OBLIGATOIREMENT</strong> les méthodes <code>accessibilityIncrement()</code> et <code>accessibilityDecrement()</code>.
</br></br>On élimine ainsi toutes les contraintes rencontrées initialement et on obtient, en plus, un <code>hint</code> lié à ce nouveau <code>trait</code> qui indique la manipulation nécessaire au bon fonctionnement.
</br><img style="max-width: 1000px; height: auto; " src="./images/iOSdev/ValeursAjustables_3.png" /></p>
<ul>
<li>Pour aboutir à ce résultat, on définit tout d&#39;abord une classe conteneur {<span lang="en">stepper</span> + <code>label</code>} qui va permettre la délégation pour la modification ultérieure de la valeur.</li>
</ul>
<pre><code class="objective-c">
-===== StepperWrapper.h =====-
NS_ASSUME_NONNULL_BEGIN
@class StepperWrapper;

@protocol AdjustableForAccessibilityDelegate <NSObject>

- (void)adjustableDecrementForView:(StepperWrapper *)view;
- (void)adjustableIncrementForView:(StepperWrapper *)view;
@end


@interface StepperWrapper : UIStackView
@property(nonatomic,weak) id<AdjustableForAccessibilityDelegate> delegate;
@end
NS_ASSUME_NONNULL_END


-===== StepperWrapper.m =====-
NS_ASSUME_NONNULL_BEGIN
@implementation StepperWrapper

- (instancetype)initWithCoder:(NSCoder *)coder {

    self = [super initWithCoder:coder];

    self.isAccessibilityElement = YES;
    self.accessibilityTraits = UIAccessibilityTraitAdjustable;

    return self;
}

- (void)accessibilityDecrement {
    [_delegate adjustableDecrementForView:self];
}

- (void)accessibilityIncrement {
    [_delegate adjustableIncrementForView:self];
}
@end
NS_ASSUME_NONNULL_END
</code></pre><pre><code class="swift">
<p>protocol AdjustableForAccessibilityDelegate: class {
    func adjustableDecrementFor(_ view: StepperWrapper)
    func adjustableIncrementFor(_ view: StepperWrapper)
}</p>
<p>class StepperWrapper: UIStackView {</p>
<pre><code>weak var delegate: AdjustableForAccessibilityDelegate?

override init(frame: CGRect) {
    super.init(frame: frame)
}

required init(coder: NSCoder) {
    super.init(coder: coder)

    isAccessibilityElement = true
    accessibilityTraits = UIAccessibilityTraitAdjustable
}

override func accessibilityDecrement() {
    delegate?.adjustableDecrementFor(self)
}

override func accessibilityIncrement() {
    delegate?.adjustableIncrementFor(self)
}</code></pre><p>}
</code></pre></p>
<ul>
<li>Ensuite, il faut redéfinir les 2 méthodes du protocole implémenté pour indiquer ce qu&#39;elles doivent réaliser avant de mettre à jour la valeur modifiée et de la présenter vocalement dans le <span lang="en">ViewController</span>.</li>
</ul>
<pre><code class="objective-c">
NS_ASSUME_NONNULL_BEGIN
@interface ViewController () <AdjustableForAccessibilityDelegate>

@property (weak, nonatomic) IBOutlet UIStepper * stepperNoAccess;
@property (weak, nonatomic) IBOutlet UILabel * stepperValueNoAccess;

@property (weak, nonatomic) IBOutlet StepperWrapper * stepperStackViewAccess;
@property (weak, nonatomic) IBOutlet UIStepper * stepperAccess;
@property (weak, nonatomic) IBOutlet UILabel * stepperValueAccess;
@end


@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];

    _stepperStackViewAccess.delegate = self;
    _stepperStackViewAccess.accessibilityLabel = @"Compteur pour adapter la valeur";
    _stepperStackViewAccess.accessibilityValue = _stepperValueAccess.text;
}

- (void)adjustableDecrementForView:(StepperWrapper *)view {
    _stepperAccess.value  -= _stepperAccess.stepValue;
    [self updateStepperValue];
}

- (void)adjustableIncrementForView:(StepperWrapper *)view {
    _stepperAccess.value  += _stepperAccess.stepValue;
    [self updateStepperValue];
}

- (void) updateStepperValue {
    _stepperValueAccess.text = [NSString stringWithFormat:@"Valeur = %0.1f",_stepperAccess.value];
    _stepperStackViewAccess.accessibilityValue = _stepperValueAccess.text;
}
@end
NS_ASSUME_NONNULL_END
</code></pre><pre><code class="swift">
<p>class ViewController: UIViewController, AdjustableForAccessibilityDelegate {</p>
<pre><code>@IBOutlet weak var stepperStackViewAccess: StepperWrapper!
@IBOutlet weak var stepperAccess: UIStepper!
@IBOutlet weak var stepperValueAccess: UILabel!


override func viewDidLoad() {
    super.viewDidLoad()

    stepperStackViewAccess.delegate = self
    stepperStackViewAccess.accessibilityLabel = &quot;Compteur pour adapter la valeur&quot;
    stepperStackViewAccess.accessibilityValue = stepperValueAccess.text
}

func adjustableDecrementFor(_ view: StepperWrapper) {
    stepperAccess.value -= stepperAccess.stepValue
    updateStepperValue()
}

func adjustableIncrementFor(_ view: StepperWrapper) {
    stepperAccess.value += stepperAccess.stepValue
    updateStepperValue()
}

private func updateStepperValue() {
    stepperValueAccess.text = &quot;Valeur = \(stepperAccess.value)&quot;
    stepperStackViewAccess.accessibilityValue = stepperValueAccess.text
}</code></pre><p>}
</code></pre></p>
<h3 id="lien">Lien</h3>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/uiaccessibilitytraitadjustable"><code>UIAccessibilityTraitAdjustable</code></a></li>
</ul>
<!--  This file is part of a11y-guidelines | Our vision of mobile & web accessibility guidelines and best practices, with valid/invalid examples.
 Copyright (C) 2016  Orange SA
 See the Creative Commons Legal Code Attribution-ShareAlike 3.0 Unported License for more details (LICENSE file). -->
          
        </div>
      </div>
    </main>

    <a aria-hidden="true" id="back-to-top" href="#" class="btn btn-primary btn-lg back-to-top" role="button" title="Retour en haut de page" data-toggle="tooltip" data-placement="left"></a>
        
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.2.0/js/tether.min.js" integrity="sha384-Plbmg8JY28KFelvJVai01l8WyZzrYWG825m+cZ0eDDS1f7d/js6ikvy1+X+guPIB" crossorigin="anonymous"></script>
    <script src="../boosted/js/boosted.min.js"></script>
    <script type="text/javascript" src="../js/reco.js"></script>
    <script type="text/javascript" src="../../../js/highlight.min.js"></script>
</body>
</html>
